# HFT CPU Mapper - Technical Manual

## 1. Architecture Overview

The **HFT CPU Mapper** is a specialized tool for visualizing and optimizing CPU core allocation on High-Frequency Trading (HFT) infrastructure. It is built as a client-side web application (HTML/CSS/JS) designed for zero-latency interaction and secure data handling (no server-side persistence).

### Core Components

*   **`index.html`**: The structural backbone, loading all modules and defining the layout containers.
*   **`styles.css`**: Implements the **Neumorphism** design system. It handles light/dark mode adaptation, responsive scaling, and the tactile "extruded" UI aesthetics.
*   **`app.js`**: The central controller. It handles:
    *   Parsing `cpu-map.sh` / `lscpu` output.
    *   Rendering the interactive visualization (Socket -> NUMA -> L3 -> Core).
    *   Managing application state (`instances`, `isolatedCores`, `netNumaNodes`).
    *   Generating the final YAML configuration for Ansible.
*   **`cpu-optimizer.js`**: The algorithmic engine. It accepts a topology snapshot and outputs an optimized allocation plan based on strict HFT rules (Split-Brain, Islanding, Load Balancing).
*   **`hft-rules.js`**: Contains definitions for Role IDs, colors, and priority constraints.

---

## 2. Optimization Logic & Strategy

The optimizer (`cpu-optimizer.js`) uses a multi-stage heuristics engine to determine the best core placement.

### 2.1 Split-Brain & Island Detection
The system automatically detects if a server has a **Split-Brain** network topology.
*   **Islanding:** If distinct network interfaces (e.g., `net0/1` vs `hit0/1`) are bound to different NUMA nodes, the optimizer treats them as separate "Islands".
*   **Resource Partitioning:** Each Island is optimized independently. Cross-island allocation is strictly prohibited to avoid NUMA usage penalties.

### 2.2 OS & IRQ Placement
*   **OS Cores:**
    *   **Single Node:** Allocated to the first 10% of physical cores (Index 0...N).
    *   **Split-Brain:**
        *   **Island 0 (Primary):** First 10% of cores (Start of range).
        *   **Island 1 (Secondary):** Last 10% of cores (End of range).
    *   **Formula:** `floor(Total_Cores * 0.1)`, with a safety minimum of 2 cores.
*   **IRQ Cores:**
    *   **Single Node:** Fixed at **4 cores**.
    *   **Split-Brain:** Fixed at **3 cores per Island**.
    *   These cores are explicitly tagged `net_irq` and isolated from the general pool.

### 2.3 Application Allocation
1.  **Grouping:** Instances sharing cores (e.g., co-located `TrashCPU`) are grouped into a single logical unit to prevent double-counting capacity.
2.  **Mandatory Services:** Gateway, UDP, Trash, Clickhouse, RF, and Formula cores are allocated first (Tier 1 Priority).
3.  **Robot Expansion:**
    *   Robots are allocated last.
    *   **Rule:** Robots expand to fill **all remaining available cores** on the assigned NUMA node.
    *   **Zero Load Fallback:** If historical load data is missing (0%), the system defaults to the *current* core count rather than shrinking allocation, ensuring stability during migrations.

---

## 3. UI/UX Design System (Neumorphism)

The interface follows a **Neumorphism** (Soft UI) specification, prioritizing visual comfort and tactile depth.

### Key Characteristics
*   **Visual Language:** Soft shadows, rounded corners (`12px`), and low-contrast gradients.
*   **Color Palette:**
    *   Primary: **Blue (#3B82F6)** for actions and active states.
    *   Background: **#F3F4F6** (Light) / **#222222** (Dark).
    *   Shadows: Double-shadow technique (Light source top-left) to create "extruded" or "inset" effects.
*   **Adaptive Layout:** The grid uses `auto-fit` and `minmax` scaling to ensure the entire server topology fits within a single screen (Viewport Fit), preventing vertical scrolling on standard monitors.
*   **L3 Cache Visualization:** L3 groups are visually recessed (inset shadow) within the NUMA container to clearly distinguish cache boundaries without using harsh borders.

---

## 4. Input & Output Formats

### Input
The tool accepts a raw text dump generated by the `cpu-map.sh` script (or manually concatenated). Key sections required:
*   `@@LSCPU@@`: Output of `lscpu -e`. Critical for topology (Socket/Node/L3 mapping).
*   `@@NETWORK@@`: Lists interfaces and their NUMA locality (e.g., `IF:net0|NUMA:0`).
*   `@@BENDER@@`: Current configuration state (used for "Zero Load" fallback).
*   `@@LOAD_AVG_30D@@` (Optional): Historical load data for advanced resizing.

### Output (YAML)
The tool generates an Ansible-compatible YAML configuration:
*   **`isol_cpus`**: Range of isolated cores (e.g., `2-15,18-31`).
*   **`net_cpus`**: Map of interfaces to IRQ cores.
*   **`bs_instances`**: Dictionary of application instances with specific core pinnings:
    *   `trash_cpu`, `gateways_cpu`, `robots_cpu`, `udpsend_cpu`, etc.
    *   `cpualias_custom`: XML blocks for specialized roles (Formula, Isolated Robots).

---

## 5. Operational Procedures

### Step 1: Ingestion
Paste the server data into the **Data Input** panel (Left Sidebar). Click **Build Map**.
*   *Verification:* Ensure the "Sockets", "Net NUMA", and "Total Cores" stats in the header match the physical hardware.

### Step 2: Analysis & Manual Adjustment (Optional)
*   **Visualization:** Hover over cores to see their role, load, and IRQ status.
*   **Manual Tools:** Use the **Paint Tools** palette to manually assign roles (e.g., drag "Gateway" across a row of cores).
*   **Cleaning:** `Ctrl + Click` on a core to strip all roles and isolation.

### Step 3: Auto-Optimization
1.  Navigate to the **Auto-Optimize** tab.
2.  Click **Generate Optimization**.
3.  Review the proposal:
    *   Check **OS Cores** count (Should be ~10%).
    *   Check **IRQ Cores** count (3-4 per island).
    *   Verify Instance allocation scores.
4.  Click **Apply to Map** to visualize the new layout on the main canvas.

### Step 4: Export
Go to the **Config Output** panel:
*   **Copy JSON:** Saves the internal state (useful for sharing configs via URL).
*   **Ansible Export:** Generates the `host_vars` YAML for deployment.

---

## 6. Troubleshooting

### Issue: "L3 caches look merged"
*   **Cause:** CSS shadow conflict or flat monitor settings.
*   **Fix:** The Neumorphic design uses subtle *inset* shadows for L3 containers. Ensure your monitor contrast is calibrated. In Dark Mode, this separation is more distinct.

### Issue: "Sidebar doesn't scroll"
*   **Fix:** Fixed in v5.2. The sidebar now uses `flex: 1; min-height: 0; overflow-y: auto;` to guarantee scrollability on smaller viewports.

### Issue: "Optimizer allocates too few cores"
*   **Cause:** Missing `@@LOAD_AVG@@` data.
*   **Fix:** The logic now defaults to the *current* core count if load data is zero. Ensure your input data contains the `BENDER` section so the tool knows the current state.

### Issue: "Wrong OS Core Count"
*   **Logic:** The system strictly calculates `floor(Total * 0.1)`. For a 64-core system, this is `6` (3 per node). If you see `8`, you might be on a system with Hyperthreading disabled or different physical topology. The tool trusts `lscpu` completely.
